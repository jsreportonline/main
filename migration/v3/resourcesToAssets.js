const { nanoid } = require('nanoid')
const MongoClient = require('mongodb').MongoClient
const winston = require('winston')
const createDefaultLoggerFormat = require('../createDefaultLoggerFormat')
const defaultLoggerFormatWithTimestamp = createDefaultLoggerFormat({ timestamp: true })

const connectionString = process.env.connectionString || 'mongodb://localhost:27017'
const database = process.env.databaseName || 'multitenant'
const rootDatabase = process.env.rootDatabaseName || 'multitenant-root'

const logger = winston.createLogger({
  format: defaultLoggerFormatWithTimestamp(),
  transports: [
    new winston.transports.Console({ level: 'info', format: winston.format.combine(winston.format.colorize(), defaultLoggerFormatWithTimestamp()) })
  ]
})

async function migrate () {
  logger.info(`connecting to ${connectionString}, root db: ${rootDatabase}, db: ${database}`)

  const client = await MongoClient.connect(connectionString, { useNewUrlParser: true, useUnifiedTopology: true })
  const rootDb = client.db(rootDatabase)
  const db = client.db(database)

  const tenants = await rootDb.collection('tenants').find({ }).project({ _id: 1, name: 1 }).toArray()

  let currentTenant
  let tCounter = 1
  let templatesMigrated = 0

  try {
    // eslint-disable-next-line no-unused-vars
    for (const t of tenants) {
      currentTenant = t.name

      if (tCounter++ % 100 === 0) {
        logger.info(`processing ${tCounter}/${tenants.length} tenants`)
      }

      const templateIds = await db.collection('templates').find({ tenantId: t.name }).project({ _id: 1 }).toArray()

      const templateToAssetResourcesMap = new Map()
      const dataToAssetMap = new Map()
      const dataEntitiesToRemove = []

      // eslint-disable-next-line no-unused-vars
      for (const templateId of templateIds) {
        const template = await db.collection('templates').findOne({ _id: templateId._id, tenantId: t.name })

        if (template.resources == null) {
          continue
        }

        // there is some garbage...
        if (template.name == null) {
          continue
        }

        if (Array.isArray(template.resources.items)) {
          // eslint-disable-next-line no-unused-vars
          for (const dataItem of template.resources.items) {
            const dataEntity = await db.collection('data').findOne({ shortid: dataItem.shortid, tenantId: t.name })

            if (dataEntity) {
              let newAsset

              if (dataToAssetMap.has(dataEntity.shortid)) {
                newAsset = dataToAssetMap.get(dataEntity.shortid)
              } else {
                const assetProps = {
                  content: Buffer.from(dataEntity.dataJson || ''),
                  folder: dataEntity.folder || null
                }

                if (dataEntity.readPermissions != null) {
                  assetProps.readPermissions = dataEntity.readPermissions
                }

                if (dataEntity.editPermissions != null) {
                  assetProps.editPermissions = dataEntity.editPermissions
                }

                newAsset = await insertUnique(db, 'assets', `${dataEntity.name}.json`, assetProps, t.name)

                dataToAssetMap.set(dataEntity.shortid, newAsset)
              }

              const assetResources = templateToAssetResourcesMap.get(template.shortid) || []

              assetResources.push({
                ...newAsset,
                originalName: dataEntity.name
              })

              templateToAssetResourcesMap.set(template.shortid, assetResources)
              dataEntitiesToRemove.push(dataEntity)
            }
          }
        }

        const templateAssetResources = templateToAssetResourcesMap.get(template.shortid) || []

        if (templateAssetResources.length > 0) {
          const scriptProps = {
            content: (
  `
  // THIS SCRIPT WAS GENERATED BY MIGRATION IN V3, IT PROVIDES BACKWARD COMPATIBILITY
  // WITH THE DEPRECATED jsreport-resources https://jsreport.net/learn/resources
  // THE RECOMMENDATION NOW IS TO USE jsreport-localization https://jsreport.net/learn/localization
  // SO WHEN YOU DECIDE TO USE jsreport-localization TO FULLY REPLACE THE jsreport-resources
  // JUST REMOVE THIS SCRIPT FROM YOUR TEMPLATE AND DELETE IT
  const jsreport = require('jsreport-proxy')
  
  async function beforeRender (req, res) {
    req.options.language = req.options.language || req.template.localization?.language
    const defaultLanguage = ${template.resources.defaultLanguage != null ? '\'' + template.resources.defaultLanguage + '\'' : 'undefined'}
    const assetsResources = [${templateAssetResources.map(a => `{ name: '${a.originalName}', shortid: '${a.shortid}' }`).join(', ')}]
  
    const resources = await Promise.all(assetsResources.map(async (r) => {
      const asset = await jsreport.documentStore.collection('assets').findOne({ shortid: r.shortid })
  
      if (asset == null) {
        throw new Error(\`Asset resources with shortid \${r.shortid} was not found (resource lookup)\`)
      }
  
      asset.resourceName = r.name
      asset.content = asset.content.toString()
  
      return asset
    }))
  
    resources.forEach((r) => {
      r.dataJson = r.content
      r.data = JSON.parse(r.content)
    })
  
    req.options.resources = resources
    req.data.$resources = resources
  
    const resourcesByName = {}
  
    resources.forEach((r) => {
      resourcesByName[r.resourceName] = r.data
    })
  
    req.options.resource = resourcesByName
    req.data.$resource = resourcesByName
  
    const isLocalizedRequest = req.options.language != null || defaultLanguage != null
  
    if (isLocalizedRequest) {
      let languageUsed
      let applicableResources = []
  
      if (req.options.language) {
        languageUsed = req.options.language
        applicableResources = resources.filter((r) => r.resourceName.startsWith(\`\${languageUsed}-\`))
      }
  
      if (!applicableResources.length && defaultLanguage) {
        languageUsed = defaultLanguage
        applicableResources = resources.filter((r) => r.resourceName.startsWith(\`\${languageUsed}-\`))
      }
  
      console.log(\`Found \${applicableResources.length} resources for language "\${languageUsed}"\`)
  
      req.options.localizedResources = applicableResources
      req.data.$localizedResources = applicableResources
  
      const localizedResourceByName = {}
  
      applicableResources.forEach((r) => {
        localizedResourceByName[r.resourceName.substring(\`\${languageUsed}-\`.length)] = r.data
      })
  
      req.options.localizedResource = applicableResources.length === 1 ? applicableResources[0].data : localizedResourceByName
      req.data.$localizedResource = req.options.localizedResource
    }
  }
  `
            ),
            folder: template.folder || null
          }

          if (template.readPermissions != null) {
            scriptProps.readPermissions = template.readPermissions
          }

          if (template.editPermissions != null) {
            scriptProps.editPermissions = template.editPermissions
          }

          const newScript = await insertUnique(db, 'scripts', `${template.name}_resources`, scriptProps, t.name)

          template.scripts = template.scripts || []

          template.scripts.unshift({
            shortid: newScript.shortid
          })
        }

        template.resources = null

        templatesMigrated++

        await db.collection('templates').updateOne({ _id: template._id, tenantId: t.name }, { $set: template })
      }

      // eslint-disable-next-line no-unused-vars
      for (const dataEntity of dataEntitiesToRemove) {
        const templateWithDataReferenced = await db.collection('templates').findOne({
          tenantId: t.name,
          'data.shortid': dataEntity.shortid
        })
        if (templateWithDataReferenced != null) {
          continue
        }
        await db.collection('data').removeOne({ _id: dataEntity._id, tenantId: t.name })
      }
    }
  } catch (e) {
    e.message = `Current tenant: ${currentTenant}, Error: ${e.message}`
    throw e
  }

  if (templatesMigrated > 0) {
    logger.info(`migrated templates with resources ${templatesMigrated}`)
  } else {
    logger.info('no templates to migrate!')
  }

  await client.close()
}

logger.info('starting query..')

migrate().then(() => {
  logger.info('============================')
  logger.info('finished!')
}).catch((err) => {
  logger.error('Error while executing query:')
  logger.error(err.toString())
})

const collections = ['assets', 'data', 'tags', 'users', 'schedules', 'templates', 'folders', 'scripts']
function findDuplicate (db, collectionName, name, entity, tenantName) {
  return db.collection(collectionName).findOne({
    tenantId: tenantName,
    name,
    folder: entity.folder || null
  })
}

async function insertUnique (db, collectionName, baseName, entity, tenantName) {
  let tryCount = 0

  while (true) {
    const entityName = '_'.repeat(tryCount) + baseName

    let duplicate
    // eslint-disable-next-line no-unused-vars
    for (const collection of collections) {
      const duplicate = await findDuplicate(db, collection, entityName, entity, tenantName)
      if (duplicate != null) {
        break
      }
    }

    if (duplicate != null) {
      tryCount++
      continue
    }

    const newEntity = {
      ...entity,
      tenantId: tenantName,
      creationDate: new Date(),
      modificationDate: new Date(),
      shortid: nanoid(7),
      name: entityName
    }

    await db.collection(collectionName).insertOne(newEntity)

    return newEntity
  }
}
